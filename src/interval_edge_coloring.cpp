#include <algorithm>
#include <chrono>
#include <ctime>
#include <fstream>
#include <iostream>
#include <random>
#include <vector>

#include "../include/interval_edge_coloring.h"

// Graph6 format details: https://users.cecs.anu.edu.au/~bdm/data/formats.txt
void IntervalEdgeColoring::AdjacencyFromGraph6(const std::string graph6) {
    vertices_ = graph6[0] - 63;
    adj_matrix_.resize(vertices_, std::vector<int>(vertices_, 0));
    int row;
    int bit_vector;
    int ch = 1;
    int is_set = 32;
    int bits = 6;
    for (int col = 1; col < vertices_; ++col) {
        for (row = 0; row < col; ++row) {
            if (bits == 6) {
                bits = 0;
                bit_vector = graph6[ch++] - 63;
            }
            ++bits;
            if (bit_vector & is_set) {
                adj_matrix_[row][col] = 1;
                adj_matrix_[col][row] = 1;
            }
            bit_vector <<= 1;
        }
    }
}

void IntervalEdgeColoring::BiadjacencyFromAdjacency() {
    SetBipartition();
    biadj_matrix_.resize(rows_, std::vector<int>(columns_, 0));
    deg_row_.resize(rows_);
    deg_col_.resize(columns_);
    for (int j = rows_; j < vertices_; ++j) { 
        for (int i = 0; i < rows_; ++i) {
            if (adj_matrix_[i][j]) {
                ++deg_row_[i];
                ++deg_col_[j - rows_];
                biadj_matrix_[i][j - rows_] = 1;
            }
        }
    }
}

void IntervalEdgeColoring::SetBipartition() {
    for (int i = 0; i < adj_matrix_.size(); ++i) {
        if (adj_matrix_[0][i] == 1) {
            rows_ = i;
            columns_ = vertices_ - rows_;
            return;
        }
    }
}

void IntervalEdgeColoring::Reset() {
    rows_ = 0;
    columns_ = 0;
    vertices_ = 0;
    adj_matrix_.clear();
    biadj_matrix_.clear();
    coloring_.clear();
    arr_row_.clear();
    arr_col_.clear();
    deg_row_.clear();
    deg_col_.clear();
}

// Assigns a color to the 1st cell of the coloring_ matrix, as there is always 
// an edge between the 1st vertices of the bipartition generated by Nauty.
// Calls RecursiveColoring() on the next cell to continue coloring 
// the rest of the matrix recursively.
bool IntervalEdgeColoring::SearchIntervalColoring(int color) {
    coloring_.resize(rows_, std::vector<int>(columns_, 0));
    arr_row_.resize(rows_, std::vector<uint32_t>(columns_, 0));
    arr_col_.resize(rows_, std::vector<uint32_t>(columns_, 0));
    SetColor(0, 0, color);
    bool has_coloring = RecursiveColoring(1, 0);
    if (has_coloring) {
        return true;
    }
    return false;
}

// Backtracking algorithm for coloring a biadjacency matrix such that each row and column
// contains a unique consecutive sequence of numbers, with 0s being excluded.
// Traverses the matrix column-wise, from top to bottom, left to right.
bool IntervalEdgeColoring::RecursiveColoring(int row, int column) {
    if (TimeElapsed() > time_limit_) {
        time_limited = true;
        return false;
    }
    if (column == columns_) {
        return true; // found a coloring
    }
    if (biadj_matrix_[row][column] == 0) {
        return RecursiveColoring(row == rows_ - 1 ? 0 : row + 1, column + (row == rows_ - 1));
    }
    std::vector<int> possible_colors;
    DeterminePossibleColors(row, column, possible_colors);
    int count = 0;
    bool continue_loop;
    do {
        if (possible_colors.size() <= count) {
            return false; // all the possible colors are tested
        }
        SetColor(row, column, possible_colors[count++]);
        continue_loop = RecursiveColoring(row == rows_ - 1 ? 0 : row + 1, column + (row == rows_ - 1));
        if (!continue_loop) {
            ClearColor(row, column);
        } 
    } while (!continue_loop);
    return true;
}

// Determines the possible color set for a given matrix cell.
void IntervalEdgeColoring::DeterminePossibleColors(int row, int column, std::vector<int>& possible_colors) {
    int color = 1;
    int down_limit = 1;
    int up_limit = 28;
    bool is_arr_col = arr_col_[row][column] != 0;
    bool is_arr_row = arr_row_[row][column] != 0;
    if (is_arr_col) {
        color = GetMaxUsedColor(arr_col_[row][column]) - deg_col_[column] + 1;
    }
    if (down_limit < color) {
        down_limit = color;
    }
    if (is_arr_row) {
        color = GetMaxUsedColor(arr_row_[row][column]) - deg_row_[row] + 1;
        if (down_limit < color) {
            down_limit = color;
        }
    }
    if (is_arr_col) {
            color = GetMinUsedColor(arr_col_[row][column]) + deg_col_[column] - 1;
            if (up_limit > color) {
            up_limit = color;
        }
    }
    if (is_arr_row) {
        color = GetMinUsedColor(arr_row_[row][column]) + deg_row_[row] - 1;
        if (up_limit > color) {
            up_limit = color;
        }
    }
    possible_colors.clear();
    uint32_t used_colors = arr_row_[row][column] | arr_col_[row][column]; 
    used_colors >>= down_limit;
    for (int i = down_limit; i <= up_limit; ++i) {
        if (!(used_colors & 1)) {
            possible_colors.push_back(i);
        }
        used_colors >>= 1;
    }
    std::default_random_engine g(std::time(nullptr));
    std::shuffle(possible_colors.begin(), possible_colors.end(), g);
}

void IntervalEdgeColoring::SetColor(int row, int column, int color) {
    coloring_[row][column] = color;
        for (int i = row + 1; i < rows_; ++i) {
            arr_col_[i][column] |= 1 << color;
        }
        for (int j = column + 1; j < columns_; ++j) {
            arr_row_[row][j] |= 1 << color;
        }
}

void IntervalEdgeColoring::ClearColor(int row, int column) {
    int color = coloring_[row][column];
    for (int i = row + 1; i < rows_; ++i) {
        arr_col_[i][column] &= ~(1 << color);
    }
    for (int j = 0; j < columns_; ++j) {
        arr_row_[row][j] &= ~(1 << color);
    }
}

// Gets the min used color in a particular row/column.
int IntervalEdgeColoring::GetMinUsedColor(int used_colors) {
    int min_color = 0;
    while ((used_colors & 1) == 0) {
        used_colors >>= 1;
        ++min_color;
    }
    return min_color;
}

// Gets the max used color in a particular row/column.
int IntervalEdgeColoring::GetMaxUsedColor(int used_colors) {
    int x = 0;
    int color;
        while (used_colors != 0) {
            if (used_colors & 1) {
                color = x;
            }
            ++x;
            used_colors >>= 1;
        }
    return color;
}

// Get the min used color in a given row of a graph coloring.
// Used by IsValidColoring().
int IntervalEdgeColoring::GetMinColorInRow(int row) {
    int min_color = 33; // Initialize with a high-value color that cannot be assigned.
    for (int column = 0; column < columns_; ++column) {
        if (coloring_[row][column]) {
            if (min_color > coloring_[row][column]) {
                min_color = coloring_[row][column];
            }
        }
    }
    return min_color;
}

int IntervalEdgeColoring::GetMinColorInColumn(int column) {
    int min_color = 33; // Initialize with a high-value color that cannot be assigned.
        for (int row = 0; row < rows_; ++row) {
            if (coloring_[row][column]) {
                if (coloring_[row][column] < min_color) {
                    min_color = coloring_[row][column];
                }
            }
        }
    return min_color;
}

// Compares the biadjacency and coloring matrices.
// Checks if each row and column contain a unique 
// consecutive sequence of colors, with 0s being excluded.
bool IntervalEdgeColoring::IsValidColoring() {
    for (int row = 0; row < rows_; ++row) {
        int min = GetMinColorInRow(row);
        int num = 0;
        int count = 0;
        for (int column = 0; column < columns_; ++column) {
            if (biadj_matrix_[row][column] == 0 && coloring_[row][column] != 0) {
                return false;
            }
            if (biadj_matrix_[row][column] != 0 && coloring_[row][column] == 0) {
                return false;
            }
            if (coloring_[row][column]) {
                ++count;
                num ^= min ^ coloring_[row][column];
                min += 1;
            }
        }
        if(num != 0 && count != 1) {
            return 0;
        }
    }

    for (int column = 0; column < columns_; ++column) {
        int min = GetMinColorInColumn(column);
        int num = 0;
        int count = 0;
        for (int row = 0; row < rows_; ++row) {
            if (coloring_[row][column]){
                ++count;
                num ^= min ^ coloring_[row][column];
                min += 1;
            }
        }
        if(num != 0 && count != 1) {
            return 0;
        }
    }
    return true;
}

void IntervalEdgeColoring::SetStartTime() {
    start_time_ = std::chrono::steady_clock::now();
  }

// for each colored graph
void IntervalEdgeColoring::SetElapsedTime() {
    elapsed_time_ = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - start_time_).count();
}

void IntervalEdgeColoring::SetTimeLimit(int time_limit) {
    time_limit_ = time_limit;
}

long long IntervalEdgeColoring::TimeElapsed() {
    return std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - start_time_).count();
}

bool IntervalEdgeColoring::IsTimeLimited() {
    return time_limited;
}